Vorbereitung
	September - Dezember 2014
		-> Themenfindung
		-> Papers lesen

	Jänner 2014
		-> Orginalpaper nochmal genau durchgehen
			-> Andere Papers anschauen:
			-> Geanakoplos
			-> Gode & Sunders

	Februar
		-> Buch über Entscheidungstheorie
		-> Meetings mit HV und Thomas Breuer
		-> LaTex aufsetzen 
		-> Struktur der Masterarbeit definieren
		-> Literaturrecherche	
		-> Softwarerecherche
			-> Java weil: das ursprüngliche framework von breuer & al. in Java, ausserdem vielzahl an existierenden frameworks, die leicht zu integrieren sind
			-> C++ nicht: wäre zwar schneller aber nur wenn richtig verwendet => mehraufwand und geschwindigkeit nicht unbedingt so extrem kritisch, ausserdem immer großer puff mit frameworks
			-> Graphenbibliothek für Java
		-> Abstract & Einleitung schreiben
		
Arbeitsschritte & Meilensteine bis zur Abgabe
	Implementieren von netzwerken in das existierende framework: visualisieren der vorgänge des frameworks
		- Gui: SWING
		- Netzwerk-visualisierng: JUNG
		- Diagramme: JFreeChart
		- Network generator: selber bauen
			- random
			- scale-free
			- small-world
			- clustering
	
	3 Netzwerke überlegen bei denen Hypothese erfüllt und 3 bei denen nicht.
		- 3 die ok sind
			1: linearer graph: d.h. aufsteigend paarweise verbunden
		- 3 die nicht ok sind
			1: watts-strogatz
			2: barbasi modell
			3: ?
		
	Javaprogramm
		- Realtime-Visualisierung der Vermögensverteilungen der Agenten
		- Realtime-Visualisierung der Netzwerke
		- Netzwerke generieren: fixe Anzahl Agenten, verbindungen unter ihnen nach einer gewissen Topologie
			1. paarweise aufsteigend
			2. Watts-Strogatz
			3. Barbasi
		- Handelsbeziehungen über das Netzwerk auswählen d.h. das matching probiert nur zwischen diesen zwei benachbarten agenten
		- Code refaktoring und aufräumen
		

Zeitpunkte
	Finale Abgabe am 27.

	Bis Februar
		-> Thema fixieren
		-> Literaturübersicht
		-> Orginalpaper komplett verstanden
		-> Softwareframeworks ausgesucht
		-> Grundlegend mit Softwareframeworks und Code vom Paper vertraut gemacht
		-> LaTex Software und Template eingerichtet 
		
	März: IMPLEMENTIERUNG
		-> OK		Realtime-Visualisierung der Vermögensverteilungen der Agenten
		-> OK		Realtime-Visualisierung der Netzwerke
		-> OK		Netzwerke generieren: fixe Anzahl Agenten, verbindungen unter ihnen nach einer gewissen Topologie
		-> OK		Handelsbeziehungen über das Netzwerk auswählen d.h. das matching probiert nur zwischen diesen zwei benachbarten agenten
		-> OK		gewichte bei erfolgreicher transaktion: inkrementieren/einmal auf 1 setzen
		-> OK		Auch für Auktionen mit Loan funktioniert: AuctionWithLoan, AgentsWithLoan, TransactionWithLoan
		-> OK		schönere layouts
		-> OK		Code refaktoring und aufräumen: inner classes herausziehen wo sinnvoll
		-> OK		Netzwerkvisualisierung > 50 Agenten unsichtbar
		-> OK		Beschleunigung: matching auf nachbaren und nicht globales offering book
		
		-> NEIN		Multithreaded: kurz probiert, viel zu komplex, müsste die ganze backend-architektur komplett umbauen und selbst dann ists noch fraglich ob es wirklich was bringt
					großer nutzen nur bei vielen agenten (ab 500) und für das gleichgewicht auch schon unter 100 agenten ausreichen 
		
	April: THEORIE VERTIEFUNG, AUSARBEITUNG und IMPLEMENTIERUNG
		-> OK		Offer-Book: Anzeigen der Besten-Offers eines Agenten nach jeder TX
		-> OK		Paretofront visualisieren
		-> OK		History der offer-books & wealth-visualisierung: speichere für jede erfolgreiche TX die zustände der agents und deren offers
		-> OK		im programm feststellen, dass kein handeln mehr möglich ist
		-> OK		Klarheit wieso konvergenz bei Asset-Cash in beiden Topologien aber Asset-Loan nur bei FULLY_CONNECTED gegeben ist
		-> OK		TX-Controls Buttons besser layouten, diverse refaktorisierungen
		-> OK		Refactoring:
					OK Transaction & TransactionWithLoans zusammenführen
					OK Auction & AuctionWithLoans zusammenführen
					OK Agent & AgentWithLoans zusammenführen
					OK ABM, LOAN/CASH und BP schalter in den agent hineintragen
		-> OK		nurmehr einen loan-type und diesen änderbar machen
		-> OK		Formeln zu ABM und loan-Cash von martin übernehmen um pareto-front wegzubekommen => keine liste mehr pro markt, nurmehr ein ask/bid 	
		-> OK		Einschränkung aufheben, dass Asset-Loans erst gehandelt werden dürfen, wenn kein Cash mehr vorhanden
		-> OK		Loan-Cash Markt aktivieren und funktionierbar bekommen
		-> OK		BP (=CC von martin) einbauen
		-> OK		Märkte müssen mit martin jandackas gleichungen funktionieren
		-> OK		Über mehrere Läufe mitteln und grafisch auch darstellen
						sollte relativ einfach sein: die endzustände aller läufe aufbewahren und dann die vermögensverteilungen mitteln
						OK gui unterstützt
						OK PARALLELISIERT !!!!
					OK 2 Tabs in Hauptfenster: Inspector (bisherige Funktionalität) und Replicator
					OK MainWindow wird zum InspectorPanel
					OK Neues MainWindow: instantiiert nur InspectorPanel und ReplicatorPanel und fügt es in ein TabbedPane ein
					OK WICHTIG: Inspection und Replication sollen gleichzeitig funktionieren
					OK Replicator
						OK controls wie bei Inspector (siehe oben)
						OK anzahl replikationen einstellbar
						OK parallelisieren (bis zu N Threads gleichzeitig - N anzahl der Prozessorkerne)
						OK abbruchbedingungen einstellbar: kein handel mehr möglich, N unsuccessful TXs
						OK agent-inspektor der endzustände
		-> OK	 	Replication Inspector
					OK zeigt die momentan laufenden replikationen inklusive fortschritt an (nur bei MAX TOTAL TX)
					OK erlaubt eine einzelne replikation zu canceln
					OK erlaubt die vermögensverteilung einer einzelne replikation hineinzuschauen:

Implementierung		
	-> TODO		Gleichgewichtszustand wie im Paper feststellen
	-> TODO		Importance Sampling
				-> Initiale Sampleanzahl von Anzahl der Agenten und Topologie abhängig: wie berechnen
					-> Variante mit Sampling muss mindestens gleich gut funktionieren wie die mit uniform random 
				-> Neue Samples müssen mit einer gewissen Wahrscheinlichkkeit hinzugefügt werden: welcher?
					-> Integralfläche?
					-> Wichtigkeit des Samples?
				
	-> TODO 	experimente definieren und beobachten
				
	-> TODO		Bugfixes
					- wenn network hidden in inspection-mode und ein anderes network ausgewählt wird und dann wieder show network, dann ist noch das ursprüngliche angezeigt

Schreiben
	-> TODO		SCHREIBEN: Introduction 
	-> TODO		SCHREIBEN: Implementation
	-> TODO		SCHREIBEN: Paper berschreiben
	-> TODO		SCHREIBEN: implementierung beschreiben und unterschiede zum paper
		
	-> TODO		SCHREIBEN: Theorie Dieser erst ganz zum schluss, damit der theorieteil einen sinnvollen kontext bekommt und nicht bloß als trockener nackter theorieteil daherkommt, 
				den man vor jede andere x-beliebige masterthesis setzen kann die sich auch mit komplexeren netzwerken auseinandersetzt.
	-> TODO		SCHREIBEN: "Conclusions and Perspectives" schreiben.


Wenn noch zeit:
	-> TODO		Optimieren von Matchingwahrscheinlichkeiten
				anpassung an die nachbar limitprices, aber nicht deterministisch sondern auch zufällig ( mit 1/10 diese optimierung machen und dann untersuchen). 
				somit kommt es mit höherer wahrscheinlichkeit zu matches zwischen ascending-nachbaren. ABER: dann keine reinen zero-intelligence agents.
				-> IMPORTANCE-SAMPLING
				-> upper/lower limit immer auf nachbar käufer/verkäufer limitprice setzen funktioniert bei ascending_connected nicht - wieso eigentlich nicht? wahrscheinlich reduziert es die wahrscheinlichkeit noch mehr
				-> ober/unter grenze währenddessen erlernen d.h. bei erfolgreichen transaktionen nach oben bzw. unten verschieben und dann mit einer 50% wahrscheinlichkeit daraus ziehen funktioniert auch nicht
	-> TODO		wieder mehere bond-typen zurückeinbauen, da ein wesentlicher punkt im paper ist, dass wenn mehrere loans zur verfügung stehen, die riskioreichen NICHT gehandelt werden

	-> TODO		Refatorings